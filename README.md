# exe001

//readme

//id:211998646
//mail:yehuda029974129@gmail.com

                                                        Graph.hpp:

                                        :הצהרה על מחלקת גרף המשתנים שיגדירו את הגרף ושתי המתודות שלה

                                        :בחרתי להגדיר ארבעה משתנים

                                        -מספר קודקודים-   הינו מספר השורות והעמודות בגרף

                                        -מספר צלעות-     מספר התאים בטבלה ששונים מאפס ובגרף מכוון חצי מזה

                                        משתנה בולאני האם הגרף עם משקלים או לא-

                                        והגרף עצמו מיוצג על ידי וקטור שמכיל וקטורים- 


                                        :מתודות

                                        -מתודה ראשונה להכנסת ערכים למשתני המחלקה:   תקבל גרף ולא תחזיר כלום

                                        -מתודה שנייה להדפסת מספר הקודקודים והצלעות 


                                                          Graph.cpp

                                        -מימוש של שני המתודות המוצהרות

              -מתודה ראשונה ראשית תבדוק כי הקלט תקין ולאחר מכן תאפס את משתני המחלקה ותכניס את הערכים הרצויים לגרף תוך כדי הגדרת משתני המחלקה בהתאם

              -מתודה שנייה תדפיס את הייצוג של הגרף בעזרת משתני המחלקה


                                                      Algorithms.hpp

                          -נצהיר על מחלקה עם הצהרות עבור מתודות למימושים של אלגוריתמים שונים על גרף הסבר על כל מתודה בהמשך


                                                      Algorithms.cpp

                                      מימוש המתודות שהוצהרו בצורה הבא:

            static std::vector<std::pair<std::string, size_t>> bfsSreach(const Graph& g, size_t start);

            -המתודה הפומבית הבאה נועדה לעזור במימוש המתודות האחרות שנדרש לבנות
            היא תקבל:
            -אובייקט של גרף
            -וקודקוד להתחלת מסלולים
            היא תחזיר:
            -וקטור בו האינדקס מייצג קודקוד והערך את המסלול בעל מספר הצלעות הכי קטן אליו מקודקוד ההתחלה ואת מספר הצלעות עצמו של המסלול
            
            הסבר על הפונקציה:
            -בעצם עובדת על אלגוריתם חיפוש מסוג:
                                                                    BFS
            נתחיל בקודקוד שקיבלנו ונעבור על שכניו ונעדכן את מסלולם בהתאם ולאחר מכן יסיים עם הקודקוד ויעבור על הקודקודים השכנים בצורה דומה
            

            static std::vector<std::pair<std::string, int>> bellmanFord(const Graph& g, size_t start);
            -גם מתודה פונמבית שנועדה לעזור לנו במימוש שאר הפונקציות:
            מקבלת:
            -אובייקט גרף
            -קודקוד התחלה
            מחזירה:
            -וקטור בו כל אינדקס מייצג קודקוד והערך של התא יהיה המסלול בעל המשקל הכולל הכי שטן מקודקוד ההתחלה וסכום המסלול

            הסבר על הפונקציה:
            -עובדת על אלגוריתם מסוג בלמן פורד שלמדנו באלגוריתמים
            שלושה לולאת ועדכון במסלול בכל פעם ולאחר שנסיים נבדוק שאין מעגל שליל שיכול לסכל להפוך את מציאת המסלול הכי קטן לאינסופי ובכך 
            לבטל את הרלוונטיות למציאת מסלול הכי קטן

            static int isConnected(const Graph& g);
            -מתודה פומבית לבדיקת הגרף אם הוא קשיר:
            היא תקבל גרף ותחזיר 1 אם הוא קשיר ו-0 אם לא

            זאת אומרת שעלינו לבדוק האם ניתן להגיע מכל קודקוד לכל שאר הקודקודים
            בעזרת פונקציית העזר שבינית לחיפוש bfs אני שולח בכל פעם קודקוד אחר לבדיקת מסלול לכל שאר הקודקודים ואז עובר בלולאה על התוצאות במידה ומצאתי קודקוד
            שלא הצלחנו להגיע אליו נחזיר שהגרף אינו קשיר ואם לא נמצא כזה עבור המסלולים של כולם נחזיר שהגרף קשיר

            static std::string shortestPath(const Graph& g, int start, int end);
            את פונקציה זאת חילקתי לשניים במידה והגרף עם משקלים אמצא את המסלול הדרוש בעזרת הפונקצייה שממשת את אלגוריתם בלמן פורד
            ובמידה והגרף ללא משקלים אמצא את המסלול בעזרת הפונקציה למימוש חיפוש bfs

            static std::string isContainsCycle(const Graph& g);

            static std::string isBipartite(const Graph& g);

            static std::string negativeCycle(const Graph& g);
    
